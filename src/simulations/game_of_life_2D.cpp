#include <random>

#include "utilities.hpp"
#include "simulations/game_of_life_2D.hpp"

namespace Simulation {

GameOfLife2D::GameOfLife2D(uint32_t rows, uint32_t cols) :
    BaseSimulation(rows,cols,1)
{
    this->voxels.resize(rows * cols);
    size_t i = 0;
    const float voxel_size = 1.0f;

    for (int32_t row = 0; row < static_cast<int32_t>(rows); row++) {
        for (int32_t col = 0; col < static_cast<int32_t>(cols); col++) {
            uint32_t index = row*cols + col; 
            this->voxels[index].color = utils::black;
            this->voxels[index].position = { row, col, 0 };
        }
    }
    this->InitRandomState();
}

// (Re)initialize to random state
void GameOfLife2D::InitRandomState() {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::bernoulli_distribution dis(0.5);

    auto [rows, cols, _] = this->GetGridSize().elements;
    this->cells.resize(rows * cols);
    for (auto &cell : this->cells) {
        cell = dis(gen);
    }
    
    this->simulation_time = 0.0;
}

double GameOfLife2D::Step(double dt) {
    auto [rows, cols, _] = this->gridSize.elements;
    // TODO generated by copilot - inefficient to malloc every Step
    std::vector<uint8_t> next_cells = this->cells; // Ensure consistent type

    for (int32_t row = 0; row < rows; ++row) {
        for (int32_t col = 0; col < cols; ++col) {
            uint32_t index = row * cols + col;
            auto neighbours_alive = this->SumNeighbouringCells(row, col); // Pass row and col as arguments

            if (this->cells[index] == 1) {
                next_cells[index] = (neighbours_alive == 2 || neighbours_alive == 3) ? 1 : 0;
            } else {
                next_cells[index] = (neighbours_alive == 3) ? 1 : 0;
            }
        }
    }

    this->cells = std::move(next_cells); // Ensure consistent type

    for (int index = 0; index < rows * cols; ++index) {
        this->voxels[index].color = this->cells[index] ? utils::white : utils::black;
    }

    this->simulation_time += dt;
    return dt;
}

uint32_t GameOfLife2D::SumNeighbouringCells(int32_t row, int32_t col) {
    auto [rows, cols, _] = this->GetGridSize().elements;
    uint32_t sum_alive = 0;

    // done by our AI overlords
    for (int dr = -1; dr <= 1; ++dr) {
        for (int dc = -1; dc <= 1; ++dc) {
            if (dr == 0 && dc == 0) continue; // Skip the current cell

            int32_t neighbor_row = row + dr;
            int32_t neighbor_col = col + dc;

            if (neighbor_row >= 0 && neighbor_row < rows && neighbor_col >= 0 && neighbor_col < cols) {
                sum_alive += this->cells[neighbor_row * cols + neighbor_col];
            }
        }
    }

    return sum_alive;
}

}
